<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Melodic Web</title>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'SF Mono', 'Menlo', monospace;
            background: #1a1a1a;
            color: #f5f5f5;
            overflow: hidden;
            height: 100vh;
        }

        #canvas { 
            position: fixed; 
            inset: 0; 
            z-index: 0; 
        }

        #ui {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 380px;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            z-index: 10;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        h1 {
            font-size: 1rem;
            color: #d4a017;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 2px solid #d4a017;
            padding-bottom: 10px;
        }

        h2 {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 20px 0 10px 0;
        }

        .status {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.8rem;
        }

        .led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
            transition: all 0.3s;
        }

        .led.on { 
            background: #0f0; 
            box-shadow: 0 0 10px #0f0; 
        }

        button, select {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background: #2a2a2a;
            color: #f5f5f5;
            border: 1px solid #444;
            font-family: inherit;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover { background: #3a3a3a; }
        button.active { background: #d4a017; color: #000; }

        #voices-canvas {
            width: 100%;
            height: 180px;
            background: #0a0a0a;
            border: 1px solid #333;
            margin: 10px 0;
        }

        #log {
            background: #0a0a0a;
            border: 1px solid #333;
            padding: 10px;
            height: 120px;
            overflow-y: auto;
            font-size: 0.65rem;
            color: #888;
        }

        .info {
            font-size: 0.7rem;
            color: #666;
            margin-top: 10px;
            line-height: 1.4;
        }

        .key { 
            color: #d4a017; 
            font-weight: bold; 
        }

        /* === DEBUG PANEL === */
        #debug-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(20, 20, 20, 0.98);
            border-top: 2px solid #333;
            z-index: 100;
            transition: transform 0.3s ease;
            font-family: inherit;
        }

        #debug-panel.debug-collapsed {
            transform: translateY(calc(100% - 40px));
        }

        #debug-toggle {
            width: 100px;
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.98);
            border: 2px solid #333;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            padding: 8px;
            cursor: pointer;
            color: #d4a017;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 101;
        }

        #debug-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .debug-section {
            background: #0a0a0a;
            border: 1px solid #333;
            padding: 15px;
            border-radius: 4px;
        }

        .debug-section h3 {
            font-size: 0.7rem;
            color: #d4a017;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .debug-stat {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            margin-bottom: 6px;
            color: #888;
        }

        .debug-stat span:last-child {
            color: #0f0;
            font-family: monospace;
        }

        .debug-log, #dbg-preset-config {
            background: #000;
            padding: 10px;
            font-size: 0.6rem;
            font-family: monospace;
            color: #0f0;
            max-height: 180px;
            overflow-y: auto;
            white-space: pre-wrap;
            border: 1px solid #222;
        }

        #labels-container {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 5;
        }

        .node-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #d4a017;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            border: 1px solid #333;
            white-space: nowrap;
            transform: translate(-50%, -50%);
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .node-label.hidden {
            opacity: 0;
        }

        /* === CONFIGURATOR PANEL === */
        #config-panel {
            position: fixed;
            left: 0;
            top: 0;
            width: 320px;
            height: 100%;
            background: rgba(25, 25, 25, 0.98);
            border-right: 1px solid #333;
            z-index: 150;
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
            box-shadow: 5px 0 20px rgba(0,0,0,0.5);
        }

        #config-panel.panel-collapsed {
            transform: translateX(-100%);
        }

        .panel-header {
            padding: 20px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-header h2 {
            margin: 0;
            color: #d4a017;
            font-size: 0.9rem;
        }

        #config-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }

        .config-tabs {
            display: flex;
            background: #1a1a1a;
        }

        .tab-btn {
            flex: 1;
            padding: 12px;
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid transparent;
            margin: 0;
        }

        .tab-btn.active {
            color: #d4a017;
            border-bottom-color: #d4a017;
            background: rgba(212, 160, 23, 0.05);
        }

        .preset-info {
            font-size: 0.7rem;
            color: #d4a017;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .config-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .config-section {
            display: none;
        }

        .config-section.active {
            display: block;
        }

        .config-group {
            margin-bottom: 20px;
        }

        .config-group h3 {
            font-size: 0.65rem;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 10px;
            border-bottom: 1px solid #222;
            padding-bottom: 5px;
        }

        .control-row {
            margin-bottom: 12px;
        }

        .control-row label {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: #ccc;
            margin-bottom: 5px;
        }

        .control-row span.val {
            color: #d4a017;
            font-family: monospace;
        }

        .control-row input[type="range"] {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .control-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #d4a017;
            border-radius: 50%;
            cursor: pointer;
        }

        .control-row input[type="text"] {
            width: 100%;
            background: #111;
            border: 1px solid #333;
            color: #0f0;
            padding: 5px;
            font-family: monospace;
            font-size: 0.7rem;
        }

        .config-actions {
            padding: 20px;
            border-top: 1px solid #333;
            background: #1a1a1a;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        #config-toggle {
            position: fixed;
            left: 20px;
            top: 20px;
            width: auto;
            padding: 8px 15px;
            background: rgba(30, 30, 30, 0.9);
            border: 1px solid #444;
            color: #d4a017;
            border-radius: 4px;
            z-index: 140;
            cursor: pointer;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .file-upload {
            display: block;
            text-align: center;
            padding: 10px;
            background: #2a2a2a;
            color: #f5f5f5;
            border: 1px solid #444;
            font-size: 0.75rem;
            cursor: pointer;
            text-transform: uppercase;
        }

        .file-upload:hover { background: #3a3a3a; }

        .test-pass { color: #0f0 !important; }
        .test-fail { color: #f00 !important; font-weight: bold; }
        .test-info { color: #d4a017 !important; }

        .viz-container {
            padding: 20px 20px 0 20px;
            background: #111;
            border-bottom: 1px solid #333;
        }

        #param-viz {
            width: 100%;
            height: 100px;
            background: #111;
            display: block;
        }
    </style>
</head>
<body>
    <div id="canvas"></div>
    
    <div id="ui">
        <h1>üï∏Ô∏è Seilnetz V3.1</h1>
        
        <h2>Status</h2>
        <div class="status">
            <div id="led-audio" class="led"></div>
            <span>Audio Engine</span>
        </div>
        <div class="status">
            <div id="led-midi" class="led"></div>
            <span id="midi-status">No MIDI</span>
        </div>

        <h2>Soundscape</h2>
        <div style="margin-bottom: 15px;">
            <label style="font-size: 0.65rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 4px;">Web</label>
            <select id="web-preset">
                <option value="ambient_drone">Ambient Drone</option>
                <option value="warm_pad">Warm Pad</option>
                <option value="deep_bass">Deep Bass</option>
                <option value="bright_shimmer">Bright Shimmer</option>
                <option value="dark_pulse">Dark Pulse</option>
                <option value="crystal_bells">Crystal Bells</option>
            </select>

            <label style="font-size: 0.65rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 4px;">Harp</label>
            <select id="harp-preset">
                <option value="monochord">Monochord</option>
                <option value="plucked_strings">Plucked Strings</option>
                <option value="bell_tones">Bell Tones</option>
                <option value="soft_mallets">Soft Mallets</option>
                <option value="aggressive_hits">Aggressive Hits</option>
                <option value="ethereal_bow">Ethereal Bow</option>
            </select>
        </div>

        <h2>Active Voices</h2>
        <canvas id="voices-canvas"></canvas>

        <h2>Controls</h2>
        <button id="btn-toggle-labels">Show/Hide Labels</button>
        <button id="btn-autoplay">Toggle Auto-Play</button>

        <div class="info">
            <strong>Keyboard:</strong> 
            <span class="key">1-2</span> = Web, 
            <span class="key">3</span> = Harp<br>
            <strong>Mouse:</strong> Drag to rotate<br>
            <strong>Debug:</strong> Toggle footer panel
        </div>
    </div>

    <button id="config-toggle">‚öôÔ∏è Configure</button>

    <div id="config-panel" class="panel-collapsed">
        <div class="panel-header">
            <h2>Soundscape Configurator</h2>
            <button id="config-close">√ó</button>
        </div>
        
        <div class="config-tabs">
            <button class="tab-btn active" data-target="web-config">Web</button>
            <button class="tab-btn" data-target="harp-config">Harp</button>
        </div>

        <div class="viz-container">
            <canvas id="param-viz" width="280" height="100"></canvas>
        </div>

        <div class="config-content">
            <!-- Web Configuration -->
            <div id="web-config" class="config-section active"></div>

            <!-- Harp Configuration -->
            <div id="harp-config" class="config-section"></div>
        </div>

        <div class="config-actions">
            <button id="btn-export">Export</button>
            <label class="file-upload">
                Import
                <input type="file" id="file-import" accept=".json" hidden>
            </label>
        </div>
    </div>

    <div id="debug-panel" class="debug-collapsed">
        <button id="debug-toggle">DEBUG ‚ñ≤</button>
        <div id="debug-content">
            <div class="debug-section">
                <h3>MIDI Diagnostics</h3>
                <div class="debug-stat"><span>API:</span> <span id="dbg-midi-api">-</span></div>
                <div class="debug-stat"><span>Device:</span> <span id="dbg-midi-device">-</span></div>
                <div class="debug-stat"><span>Last Msg:</span> <span id="dbg-midi-last">-</span></div>
                <div id="midi-log" class="debug-log">Waiting for MIDI...</div>
            </div>
            
            <div class="debug-section">
                <h3>Preset Config</h3>
                <pre id="dbg-preset-config" style="height: 180px;"></pre>
            </div>
            
            <div class="debug-section">
                <h3>Synth Params</h3>
                <div id="dbg-synth-params" class="debug-log" style="height: 180px;"></div>
            </div>
            
            <div class="debug-section">
                <h3>Voice States</h3>
                <div id="dbg-voice-states" class="debug-log" style="height: 180px;"></div>
            </div>
            
            <div class="debug-section">
                <h3>Event Log</h3>
                <div id="log" class="debug-log" style="height: 180px;"></div>
            </div>

            <div class="debug-section">
                <h3>System Tests</h3>
                <button id="btn-run-tests" style="width: auto; padding: 4px 8px; margin-bottom: 10px; background: #333; color: #fff; border: 1px solid #555;">Run Integration Tests</button>
                <div id="test-results" class="debug-log" style="height: 120px; color: #ccc;"></div>
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        const WEB_PRESETS = {
            ambient_drone: {
                name: 'Ambient Drone',
                notes: [36, 43, 52, 59],  // C2, G2, E3, B3
                envelope: { attack: 1.2, decay: 0.5, sustain: 0.7, release: 12 },
                oscillator: 'sine',
                filter: 2000,
                reverb: 0.8
            },
            warm_pad: {
                name: 'Warm Pad',
                notes: [48, 52, 55, 59],  // C3, E3, G3, B3
                envelope: { attack: 0.8, decay: 0.4, sustain: 0.8, release: 10 },
                oscillator: 'triangle',
                filter: 3000,
                reverb: 0.6
            },
            deep_bass: {
                name: 'Deep Bass',
                notes: [28, 35, 40, 47],  // E1, B1, E2, B2
                envelope: { attack: 2, decay: 1, sustain: 0.6, release: 15 },
                oscillator: 'sine',
                filter: 1500,
                reverb: 0.9
            },
            bright_shimmer: {
                name: 'Bright Shimmer',
                notes: [60, 64, 67, 71],  // C4, E4, G4, B4
                envelope: { attack: 0.3, decay: 0.2, sustain: 0.9, release: 6 },
                oscillator: 'triangle',
                filter: 6000,
                reverb: 0.4
            },
            dark_pulse: {
                name: 'Dark Pulse',
                notes: [39, 44, 49, 54],  // D#2, G#2, C#3, F#3
                envelope: { attack: 0.5, decay: 0.6, sustain: 0.5, release: 8 },
                oscillator: 'sine',
                filter: 1800,
                reverb: 0.7
            },
            crystal_bells: {
                name: 'Crystal Bells',
                notes: [72, 76, 79, 83],  // C5, E5, G5, B5
                envelope: { attack: 0.01, decay: 0.3, sustain: 0.4, release: 5 },
                oscillator: 'triangle',
                filter: 8000,
                reverb: 0.5
            }
        };

        const HARP_PRESETS = {
            monochord: {
                name: 'Monochord',
                notes: [62, 67],  // D4, G4
                envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 4 },
                oscillator: 'triangle',
                filter: 5000,
                reverb: 0.5
            },
            plucked_strings: {
                name: 'Plucked Strings',
                notes: [64, 69],  // E4, A4
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 2 },
                oscillator: 'triangle',
                filter: 6000,
                reverb: 0.3
            },
            bell_tones: {
                name: 'Bell Tones',
                notes: [60, 67],  // C4, G4
                envelope: { attack: 0.02, decay: 0.5, sustain: 0.2, release: 6 },
                oscillator: 'triangle',
                filter: 7000,
                reverb: 0.6
            },
            soft_mallets: {
                name: 'Soft Mallets',
                notes: [55, 62],  // G3, D4
                envelope: { attack: 0.1, decay: 0.4, sustain: 0.4, release: 3 },
                oscillator: 'sine',
                filter: 4000,
                reverb: 0.4
            },
            aggressive_hits: {
                name: 'Aggressive Hits',
                notes: [48, 60],  // C3, C4
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.6, release: 1.5 },
                oscillator: 'square',
                filter: 8000,
                reverb: 0.2
            },
            ethereal_bow: {
                name: 'Ethereal Bow',
                notes: [68, 75],  // G#4, D#5
                envelope: { attack: 0.5, decay: 0.6, sustain: 0.7, release: 8 },
                oscillator: 'sine',
                filter: 5500,
                reverb: 0.8
            }
        };

        // MIDI Note Mapping (for testing with keyboard/controllers)
        const NOTE_MAP = { 60: 0, 62: 1, 64: 2 }; // C, D, E

        // 3D Positions
        const WEB_NODES = [
            { x: -1.5, y: 1.1, z: 0, label: 'Web 1' },
            { x: 1.5, y: 1.1, z: 0, label: 'Web 2' }
        ];

        const HARP_NODES = [
            { x: 0, y: 1.5, z: -2.5, label: 'Harp' }
        ];

        const ALL_NODES = [...WEB_NODES, ...HARP_NODES];

        // ===== EVENT BUS =====
        class Bus {
            constructor() { this.subs = {}; }
            on(e, fn) { (this.subs[e] ||= []).push(fn); }
            emit(e, d) { this.subs[e]?.forEach(fn => fn(d)); }
        }

        // ===== AUDIO ENGINE =====
        class AudioEngine {
            constructor(bus) {
                this.bus = bus;
                this.webSynth = null;
                this.harpSynth = null;
                this.filters = { web: null, harp: null };
                this.reverbs = { web: null, harp: null };
                this.webPreset = WEB_PRESETS.ambient_drone;
                this.harpPreset = HARP_PRESETS.monochord;
                this.ready = false;
                this.activeVoices = new Array(3).fill(null).map(() => ({ 
                    active: false, 
                    startTime: 0, 
                    duration: 0,
                    note: null 
                }));

                bus.on('trigger', d => this.play(d.sensor, d.velocity));
                bus.on('web-preset', name => this.setWebPreset(name));
                bus.on('harp-preset', name => this.setHarpPreset(name));
            }

            async init() {
                await Tone.start();
                
                // Web synth (4 voices)
                this.webSynth = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 4 });
                this.filters.web = new Tone.Filter(2000, 'lowpass');
                this.reverbs.web = new Tone.Reverb({ decay: 8, wet: 0.5 });
                this.webSynth.chain(this.filters.web, this.reverbs.web, Tone.Destination);

                // Harp synth (2 voices)
                this.harpSynth = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 2 });
                this.filters.harp = new Tone.Filter(5000, 'lowpass');
                this.reverbs.harp = new Tone.Reverb({ decay: 4, wet: 0.3 });
                this.harpSynth.chain(this.filters.harp, this.reverbs.harp, Tone.Destination);

                this.applyPreset();
                this.ready = true;
                this.bus.emit('audio-ready');
            }

            setWebPreset(name) {
                this.webPreset = WEB_PRESETS[name] || WEB_PRESETS.ambient_drone;
                if (this.ready) this.applyPreset();
            }

            setHarpPreset(name) {
                this.harpPreset = HARP_PRESETS[name] || HARP_PRESETS.monochord;
                if (this.ready) this.applyPreset();
            }

            updateParams(zone, params) {
                const config = zone === 'web' ? this.webPreset : this.harpPreset;
                
                // Deep merge/update
                if (params.oscillator) config.oscillator = params.oscillator;
                if (params.filter) config.filter = params.filter;
                if (params.reverb) config.reverb = params.reverb;
                if (params.envelope) {
                    Object.assign(config.envelope, params.envelope);
                }
                if (params.notes) config.notes = params.notes;

                if (this.ready) this.applyPreset();
            }

            applyPreset() {
                const web = this.webPreset;
                const harp = this.harpPreset;
                
                this.webSynth.set({
                    oscillator: { type: web.oscillator },
                    envelope: web.envelope
                });
                this.filters.web.frequency.value = web.filter;
                this.reverbs.web.wet.value = web.reverb;

                this.harpSynth.set({
                    oscillator: { type: harp.oscillator },
                    envelope: harp.envelope
                });
                this.filters.harp.frequency.value = harp.filter;
                this.reverbs.harp.wet.value = harp.reverb;
            }

            play(sensor, velocity) {
                if (!this.ready) return;

                const isHarp = sensor >= 2;
                const synth = isHarp ? this.harpSynth : this.webSynth;
                const config = isHarp ? this.harpPreset : this.webPreset;
                const noteIndex = isHarp ? sensor - 2 : sensor;
                const midiNote = config.notes[noteIndex % config.notes.length];
                const noteName = Tone.Frequency(midiNote, 'midi').toNote();
                const volume = velocity / 127;

                // Trigger
                synth.triggerAttack(noteName, Tone.now(), volume);
                const holdTime = config.envelope.attack + 0.1;
                synth.triggerRelease(noteName, Tone.now() + holdTime);

                // Track voice for visualization
                const totalDuration = config.envelope.attack + config.envelope.decay + config.envelope.release + 1;
                this.activeVoices[sensor] = {
                    active: true,
                    startTime: Date.now(),
                    duration: totalDuration * 1000,
                    note: noteName,
                    envelope: config.envelope
                };

                // Auto-deactivate after duration
                setTimeout(() => {
                    if (this.activeVoices[sensor].startTime === this.activeVoices[sensor].startTime) {
                        this.activeVoices[sensor].active = false;
                    }
                }, totalDuration * 1000);

                this.bus.emit('voice-update', this.activeVoices);
            }

            getActiveVoices() {
                return this.activeVoices;
            }
        }

        // ===== VOICE VISUALIZER =====
        class VoiceVisualizer {
            constructor(canvasId, bus) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.bus = bus;
                this.voices = new Array(6).fill(null).map(() => ({ active: false }));
                
                bus.on('voice-update', voices => {
                    this.voices = voices;
                });

                this.animate();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.draw();
            }

            draw() {
                const { width, height } = this.canvas;
                const ctx = this.ctx;
                const barHeight = height / 6;
                const now = Date.now();

                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, width, height);

                this.voices.forEach((voice, i) => {
                    const y = i * barHeight;
                    const isHarp = i >= 2;
                    const color = isHarp ? '#d4a017' : '#cc2936';
                    const label = isHarp ? `Harp ${i - 1}` : `Web ${i + 1}`;

                    // Background
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(0, y, width, barHeight - 2);

                    // Label
                    ctx.fillStyle = '#666';
                    ctx.font = '10px monospace';
                    ctx.fillText(label, 8, y + 15);

                    if (voice.active) {
                        const elapsed = now - voice.startTime;
                        const progress = Math.min(elapsed / voice.duration, 1);
                        const env = voice.envelope;
                        
                        // Calculate envelope position
                        const attackT = env.attack / (voice.duration / 1000);
                        const decayT = (env.attack + env.decay) / (voice.duration / 1000);
                        const sustainT = (env.attack + env.decay + 1) / (voice.duration / 1000);
                        
                        let amplitude = 0;
                        if (progress < attackT) {
                            amplitude = progress / attackT;
                        } else if (progress < decayT) {
                            amplitude = 1 - ((progress - attackT) / (decayT - attackT)) * (1 - env.sustain);
                        } else if (progress < sustainT) {
                            amplitude = env.sustain;
                        } else {
                            amplitude = env.sustain * (1 - (progress - sustainT) / (1 - sustainT));
                        }

                        // Bar
                        const barWidth = width * progress;
                        const barAlpha = Math.max(0.3, amplitude);
                        ctx.fillStyle = color + Math.floor(barAlpha * 255).toString(16).padStart(2, '0');
                        ctx.fillRect(0, y, barWidth, barHeight - 2);

                        // Time remaining
                        const remaining = ((voice.duration - elapsed) / 1000).toFixed(1);
                        ctx.fillStyle = '#fff';
                        ctx.fillText(`${remaining}s`, width - 40, y + 15);

                        // Note name
                        if (voice.note) {
                            ctx.fillText(voice.note, 80, y + 15);
                        }
                    } else {
                        // Idle
                        ctx.fillStyle = '#444';
                        ctx.fillText('idle', 80, y + 15);
                    }
                });
            }
        }

        // ===== 3D VISUALIZER =====
        class Visualizer {
            constructor(containerId, bus) {
                this.bus = bus;
                this.nodes = [];
                this.labels = [];
                this.showLabels = true;

                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a0a);

                this.camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
                this.camera.position.set(-3, 5, 8);
                this.camera.lookAt(0, 1, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(innerWidth, innerHeight);
                this.renderer.setPixelRatio(devicePixelRatio);
                document.getElementById(containerId).appendChild(this.renderer.domElement);

                // Lights
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const sun = new THREE.DirectionalLight(0xffffff, 0.6);
                sun.position.set(5, 10, 5);
                this.scene.add(sun);

                this.setupControls();
                this.createStructure();
                this.animate();

                bus.on('trigger', d => this.pulse(d.sensor));
                bus.on('toggle-labels', show => this.toggleLabels(show));
                window.addEventListener('resize', () => this.resize());
            }

            setupControls() {
                const canvas = this.renderer.domElement;
                let isDragging = false, prevMouse = { x: 0, y: 0 };
                let rot = { x: 0.7, y: -0.3 };

                canvas.addEventListener('mousedown', e => {
                    isDragging = true;
                    prevMouse = { x: e.clientX, y: e.clientY };
                });

                canvas.addEventListener('mousemove', e => {
                    if (!isDragging) return;
                    const dx = e.clientX - prevMouse.x;
                    const dy = e.clientY - prevMouse.y;
                    rot.y += dx * 0.005;
                    rot.x += dy * 0.005;
                    rot.x = Math.max(0.2, Math.min(1.5, rot.x));

                    const dist = 10;
                    this.camera.position.x = Math.sin(rot.y) * dist * Math.cos(rot.x);
                    this.camera.position.z = Math.cos(rot.y) * dist * Math.cos(rot.x);
                    this.camera.position.y = Math.sin(rot.x) * dist;
                    this.camera.lookAt(0, 1, 0);

                    prevMouse = { x: e.clientX, y: e.clientY };
                });

                canvas.addEventListener('mouseup', () => isDragging = false);
                canvas.addEventListener('mouseleave', () => isDragging = false);
            }

            createStructure() {
                this.group = new THREE.Group();
                this.scene.add(this.group);
                
                // Create subgroups for vibration
                this.webGroup = new THREE.Group();
                this.harpGroup = new THREE.Group();
                this.group.add(this.webGroup);
                this.group.add(this.harpGroup);

                // Materials
                const webMat = new THREE.LineBasicMaterial({ color: 0xcc2936, linewidth: 2 }); // Red
                const harpMat = new THREE.LineBasicMaterial({ color: 0xd4a017, linewidth: 2 }); // Yellow
                
                // Create sensor nodes
                ALL_NODES.forEach((pos, i) => {
                    const isHarp = i >= 2;
                    const color = isHarp ? 0xd4a017 : 0xcc2936;
                    
                    const geo = new THREE.SphereGeometry(0.25, 32, 32);
                    const mat = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        emissive: color,
                        emissiveIntensity: 0.3,
                        roughness: 0.3,
                        metalness: 0.1
                    });
                    
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(pos.x, pos.y, pos.z);
                    
                    // Add to appropriate group
                    if (isHarp) this.harpGroup.add(mesh);
                    else this.webGroup.add(mesh);
                    
                    // Store reference with animation state
                    this.nodes.push({ 
                        mesh, 
                        baseScale: 1.0, 
                        currentScale: 1.0,
                        baseEmissive: 0.3,
                        targetEmissive: 0.3,
                        zone: isHarp ? 'harp' : 'web'
                    });
                });

                // Web: Cone shape (lifted center)
                // Center point lifted to simulate being pulled up
                const centerHeight = 1.8;
                const centerPos = new THREE.Vector3(0, centerHeight, 0);
                const spokeCount = 12;
                const radius = 3.5;
                
                // Radial spokes
                for (let i = 0; i < spokeCount; i++) {
                    const angle = (i / spokeCount) * Math.PI * 2;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const y = 0.2; // Rim height
                    
                    const pts = [
                        centerPos,
                        new THREE.Vector3(x, y, z)
                    ];
                    const geo = new THREE.BufferGeometry().setFromPoints(pts);
                    this.webGroup.add(new THREE.Line(geo, webMat));
                }

                // Concentric rings (interpolated height)
                const rings = [
                    { r: 1.2, y: centerHeight * 0.6 },
                    { r: 2.4, y: centerHeight * 0.3 }
                ];
                
                rings.forEach(ring => {
                    const points = [];
                    const segments = 24;
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        points.push(new THREE.Vector3(
                            Math.cos(angle) * ring.r,
                            ring.y + 0.2,
                            Math.sin(angle) * ring.r
                        ));
                    }
                    const geo = new THREE.BufferGeometry().setFromPoints(points);
                    this.webGroup.add(new THREE.Line(geo, webMat));
                });

                // Harp: Tent-like strings on one side
                const harpStrings = 8;
                const beamWidth = 4.0; 
                const torusArc = Math.PI / 2; 
                const centerAngle = 3 * Math.PI / 2;
                
                for (let i = 0; i < harpStrings; i++) {
                    const t = i / (harpStrings - 1); 
                    const beamX = (t - 0.5) * beamWidth;
                    const top = new THREE.Vector3(beamX, 3.2, 0);
                    const angle = centerAngle + (t - 0.5) * torusArc;
                    const bottom = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        0.2, 
                        Math.sin(angle) * radius
                    );
                    
                    const pts = [top, bottom];
                    const geo = new THREE.BufferGeometry().setFromPoints(pts);
                    this.harpGroup.add(new THREE.Line(geo, harpMat));
                }

                // Static elements (Truss & Beam) - Add directly to main group
                const trussGeo = new THREE.TorusGeometry(3.5, 0.08, 8, 32);
                const trussMat = new THREE.MeshStandardMaterial({ 
                    color: 0x888888, roughness: 0.5, metalness: 0.7 
                });
                const truss = new THREE.Mesh(trussGeo, trussMat);
                truss.rotation.x = Math.PI / 2;
                truss.position.y = 0;
                this.group.add(truss);

                const beamGeo = new THREE.CylinderGeometry(0.06, 0.06, 8, 16);
                const beamMat = new THREE.MeshStandardMaterial({ 
                    color: 0x666666, roughness: 0.6 
                });
                const beam = new THREE.Mesh(beamGeo, beamMat);
                beam.rotation.z = Math.PI / 2;
                beam.position.set(0, 3.2, 0);
                this.group.add(beam);
                
                const pullStringGeo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 3.2, 0),
                    new THREE.Vector3(0, centerHeight, 0)
                ]);
                const pullStringMat = new THREE.LineBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.5 });
                this.group.add(new THREE.Line(pullStringGeo, pullStringMat));

                // Create labels
                this.labelsContainer = document.createElement('div');
                this.labelsContainer.id = 'labels-container';
                document.body.appendChild(this.labelsContainer);

                this.nodes.forEach((node, i) => {
                    const label = document.createElement('div');
                    label.className = 'node-label';
                    const isHarp = i >= 2;
                    const zone = isHarp ? 'Harp' : 'Web';
                    const num = isHarp ? i - 1 : i + 1;
                    label.innerHTML = `<strong>${zone} ${num}</strong>`;
                    this.labelsContainer.appendChild(label);
                    this.labels.push({ el: label, node: node.mesh });
                });
            }

            pulse(sensor) {
                if (sensor < this.nodes.length) {
                    const node = this.nodes[sensor];
                    
                    // Visual pop effect
                    node.currentScale = 1.5;
                    node.targetEmissive = 2.0; // Very bright flash
                    
                    // Trigger structural vibration
                    if (node.zone === 'web') {
                        this.webShake = 1.0;
                    } else {
                        this.harpShake = 1.0;
                    }
                }
            }

            toggleLabels(show) {
                this.showLabels = show;
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // Update node animations
                this.nodes.forEach(n => {
                    // Decay scale back to 1.0
                    n.currentScale += (n.baseScale - n.currentScale) * 0.1;
                    n.mesh.scale.setScalar(n.currentScale);
                    
                    // Decay emissive intensity
                    n.targetEmissive += (n.baseEmissive - n.targetEmissive) * 0.1;
                    n.mesh.material.emissiveIntensity = n.targetEmissive;
                });

                // Update vibrations
                if (this.webShake > 0.01) {
                    this.webShake *= 0.9; // Decay
                    this.webGroup.position.set(
                        (Math.random() - 0.5) * this.webShake * 0.1,
                        (Math.random() - 0.5) * this.webShake * 0.1,
                        (Math.random() - 0.5) * this.webShake * 0.1
                    );
                } else {
                    this.webGroup.position.set(0, 0, 0);
                }

                if (this.harpShake > 0.01) {
                    this.harpShake *= 0.9;
                    this.harpGroup.position.set(
                        (Math.random() - 0.5) * this.harpShake * 0.1,
                        (Math.random() - 0.5) * this.harpShake * 0.1,
                        (Math.random() - 0.5) * this.harpShake * 0.1
                    );
                } else {
                    this.harpGroup.position.set(0, 0, 0);
                }

                // Update label positions
                if (this.showLabels) {
                    this.labels.forEach(({ el, node }) => {
                        const screenPos = this.toScreenPosition(node);
                        el.style.left = screenPos.x + 'px';
                        el.style.top = screenPos.y + 'px';
                        el.classList.remove('hidden');
                    });
                } else {
                    this.labels.forEach(({ el }) => el.classList.add('hidden'));
                }

                this.renderer.render(this.scene, this.camera);
            }

            toScreenPosition(obj) {
                const vector = obj.position.clone();
                vector.project(this.camera);
                
                return {
                    x: (vector.x + 1) / 2 * innerWidth,
                    y: -(vector.y - 1) / 2 * innerHeight
                };
            }

            resize() {
                this.camera.aspect = innerWidth / innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(innerWidth, innerHeight);
            }
        }

        // ===== DEBUG PANEL =====
        class DebugPanel {
            constructor(bus, audio) {
                this.bus = bus;
                this.audio = audio;
                this.isOpen = false;
                this.panel = document.getElementById('debug-panel');
                
                // Toggle button
                document.getElementById('debug-toggle').onclick = () => this.toggle();
                
                // Update loop
                setInterval(() => this.update(), 200);
                
                // MIDI API Check
                const apiStat = document.getElementById('dbg-midi-api');
                if (navigator.requestMIDIAccess) {
                    apiStat.textContent = "Available";
                    apiStat.style.color = "#0f0";
                } else {
                    apiStat.textContent = "Not Supported";
                    apiStat.style.color = "#f00";
                }

                // MIDI logging
                bus.on('midi-connected', name => {
                    document.getElementById('dbg-midi-device').textContent = name;
                });
                
                bus.on('trigger', d => {
                    const zone = d.sensor >= 2 ? 'Harp' : 'Web';
                    this.logMIDI(`${zone} Sensor ${d.sensor} | Velocity: ${d.velocity}`);
                });
            }
            
            toggle() {
                this.isOpen = !this.isOpen;
                this.panel.classList.toggle('debug-collapsed', !this.isOpen);
                const btn = document.getElementById('debug-toggle');
                btn.textContent = this.isOpen ? 'DEBUG ‚ñº' : 'DEBUG ‚ñ≤';
            }
            
            update() {
                if (!this.isOpen) return;

                // Preset config
                document.getElementById('dbg-preset-config').textContent = 
                    JSON.stringify({
                        web: this.audio.webPreset,
                        harp: this.audio.harpPreset
                    }, null, 2);
                
                // Synth parameters
                const params = document.getElementById('dbg-synth-params');
                params.innerHTML = `
                    <div style="color: #d4a017; margin-bottom: 5px;">Web Parameters:</div>
                    <div>Filter: ${this.audio.filters.web?.frequency.value.toFixed(0)}Hz</div>
                    <div>Reverb: ${(this.audio.reverbs.web?.wet.value * 100).toFixed(0)}%</div>
                    <div>Osc: ${this.audio.webPreset.oscillator}</div>
                    
                    <div style="color: #d4a017; margin-top: 15px; margin-bottom: 5px;">Harp Parameters:</div>
                    <div>Filter: ${this.audio.filters.harp?.frequency.value.toFixed(0)}Hz</div>
                    <div>Reverb: ${(this.audio.reverbs.harp?.wet.value * 100).toFixed(0)}%</div>
                    <div>Osc: ${this.audio.harpPreset.oscillator}</div>
                `;
                
                // Voice states
                const states = document.getElementById('dbg-voice-states');
                states.innerHTML = this.audio.activeVoices.map((v, i) => 
                    `<div>Sensor ${i}: ${v.active ? `<span style="color:#0f0">ACTIVE (${v.note})</span>` : '<span style="color:#444">idle</span>'}</div>`
                ).join('');
            }
            
            logMIDI(msg) {
                const log = document.getElementById('midi-log');
                const line = document.createElement('div');
                line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
                log.prepend(line);
                if (log.children.length > 50) log.lastChild.remove();
                
                document.getElementById('dbg-midi-last').textContent = msg;
            }
        }

        // ===== UI CONTROLLER =====
        class UI {
            constructor(bus) {
                this.bus = bus;
                this.log = document.getElementById('log');
                this.autoplayInterval = null;
                this.showLabels = true;

                // Status LEDs
                bus.on('audio-ready', () => {
                    document.getElementById('led-audio').classList.add('on');
                });

                bus.on('midi-connected', name => {
                    document.getElementById('led-midi').classList.add('on');
                    document.getElementById('midi-status').textContent = name;
                });

                // Preset selectors
                document.getElementById('web-preset').addEventListener('change', e => {
                    bus.emit('web-preset', e.target.value);
                    this.addLog(`Web Preset: ${e.target.value}`);
                });

                document.getElementById('harp-preset').addEventListener('change', e => {
                    bus.emit('harp-preset', e.target.value);
                    this.addLog(`Harp Preset: ${e.target.value}`);
                });

                // Toggle labels
                document.getElementById('btn-toggle-labels').addEventListener('click', () => {
                    this.showLabels = !this.showLabels;
                    bus.emit('toggle-labels', this.showLabels);
                });

                // Auto-play
                document.getElementById('btn-autoplay').addEventListener('click', () => {
                    this.toggleAutoplay();
                });

                // Keyboard input
                document.addEventListener('keydown', e => {
                    const keyMap = { '1': 0, '2': 1, '3': 2 };
                    if (keyMap[e.key] !== undefined) {
                        const velocity = 40 + Math.random() * 80;  // Random 40-120
                        bus.emit('trigger', { sensor: keyMap[e.key], velocity: Math.floor(velocity) });
                    }
                });

                // Log triggers
                bus.on('trigger', d => {
                    const zone = d.sensor >= 2 ? 'Harp' : 'Web';
                    this.addLog(`${zone} Sensor ${d.sensor} | Vel: ${d.velocity}`);
                });

                // Set initial state based on AudioEngine defaults (reverse lookup name to key)
                // Note: This assumes keys match the options in HTML. 
                // Since we hardcoded options in HTML, let's just ensure they default to what AudioEngine uses
                // AudioEngine defaults to 'ambient_drone' and 'monochord'
                document.getElementById('web-preset').value = 'ambient_drone';
                document.getElementById('harp-preset').value = 'monochord';
            }

            toggleAutoplay() {
                if (this.autoplayInterval) {
                    clearInterval(this.autoplayInterval);
                    this.autoplayInterval = null;
                    document.getElementById('btn-autoplay').classList.remove('active');
                    this.addLog('Auto-play stopped');
                } else {
                    this.autoplayInterval = setInterval(() => {
                        // Web: gentle, infrequent
                        if (Math.random() < 0.3) {
                            const sensor = Math.floor(Math.random() * 2);
                            const velocity = 30 + Math.random() * 50;
                            this.bus.emit('trigger', { sensor, velocity: Math.floor(velocity) });
                        }
                        
                        // Harp: occasional plucks
                        if (Math.random() < 0.15) {
                            const sensor = 2; // Only 1 harp sensor at index 2
                            const velocity = 60 + Math.random() * 60;
                            this.bus.emit('trigger', { sensor, velocity: Math.floor(velocity) });
                        }
                    }, 1000);
                    document.getElementById('btn-autoplay').classList.add('active');
                    this.addLog('Auto-play started');
                }
            }

            addLog(msg) {
                const line = document.createElement('div');
                line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
                this.log.prepend(line);
                if (this.log.children.length > 50) this.log.lastChild.remove();
            }
        }

        // ===== PARAMETER VISUALIZER =====
        class ParamVisualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            draw(config) {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                const env = config.envelope;

                ctx.clearRect(0, 0, w, h);

                // Grid lines (optional)
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, h * 0.5); ctx.lineTo(w, h * 0.5);
                ctx.stroke();

                // 1. Draw Envelope (ADSR)
                // Normalize time: Attack + Decay + 1s Sustain + Release
                // We'll give 1s visual space for sustain to show the level
                const totalTime = env.attack + env.decay + 1 + env.release;
                const scaleX = w / Math.max(totalTime, 2); // Ensure minimum width
                
                const points = [
                    { x: 0, y: h }, // Start
                    { x: env.attack * scaleX, y: 0 }, // Peak
                    { x: (env.attack + env.decay) * scaleX, y: h * (1 - env.sustain) }, // Decay to sustain
                    { x: (env.attack + env.decay + 1) * scaleX, y: h * (1 - env.sustain) }, // Hold sustain
                    { x: (env.attack + env.decay + 1 + env.release) * scaleX, y: h } // Release
                ];

                // Fill
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                points.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.fillStyle = 'rgba(212, 160, 23, 0.1)';
                ctx.fill();

                // Stroke
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                points.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.strokeStyle = '#d4a017';
                ctx.lineWidth = 2;
                ctx.lineJoin = 'round';
                ctx.stroke();

                // 2. Draw Waveform Icon (Top Right)
                this.drawWaveform(config.oscillator, w - 30, 20);

                // 3. Draw Filter Info (Bottom Left text)
                ctx.fillStyle = '#666';
                ctx.font = '10px monospace';
                ctx.fillText(`Filter: ${config.filter}Hz`, 10, h - 10);
                ctx.fillText(`Reverb: ${(config.reverb * 100).toFixed(0)}%`, 10, h - 25);
            }

            drawWaveform(type, x, y) {
                const ctx = this.ctx;
                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                const sz = 15;

                if (type === 'sine') {
                    ctx.moveTo(x, y);
                    ctx.bezierCurveTo(x + sz/2, y - sz, x + sz/2, y + sz, x + sz, y);
                } else if (type === 'triangle') {
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + sz/2, y - sz/2);
                    ctx.lineTo(x + sz, y);
                } else if (type === 'square') {
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y - sz/2);
                    ctx.lineTo(x + sz/2, y - sz/2);
                    ctx.lineTo(x + sz/2, y + sz/2);
                    ctx.lineTo(x + sz, y + sz/2);
                    ctx.lineTo(x + sz, y);
                } else if (type === 'sawtooth') {
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + sz, y - sz/2);
                    ctx.lineTo(x + sz, y);
                }
                ctx.stroke();
            }
        }

        // ===== CONFIGURATOR =====
        class Configurator {
            constructor(bus, audio) {
                this.bus = bus;
                this.audio = audio;
                this.panel = document.getElementById('config-panel');
                this.toggleBtn = document.getElementById('config-toggle');
                this.closeBtn = document.getElementById('config-close');
                this.viz = new ParamVisualizer('param-viz');
                this.isOpen = false;
                this.currentZone = 'web'; // Track active tab

                this.initUI();
                this.render('web');
                this.render('harp');
                this.updateViz();

                // Listen for external preset changes
                bus.on('web-preset', name => {
                    if (this.currentZone === 'web') this.render('web');
                    this.updateViz();
                });

                bus.on('harp-preset', name => {
                    if (this.currentZone === 'harp') this.render('harp');
                    this.updateViz();
                });
            }

            initUI() {
                this.toggleBtn.onclick = () => this.toggle();
                this.closeBtn.onclick = () => this.toggle();

                // Tabs
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                        document.querySelectorAll('.config-section').forEach(s => s.classList.remove('active'));
                        btn.classList.add('active');
                        document.getElementById(btn.dataset.target).classList.add('active');
                        
                        // Update active zone for visualization
                        this.currentZone = btn.dataset.target.replace('-config', '');
                        this.updateViz();
                    };
                });

                // Export
                document.getElementById('btn-export').onclick = () => this.export();

                // Import
                document.getElementById('file-import').onchange = (e) => this.import(e);
            }

            toggle() {
                this.isOpen = !this.isOpen;
                this.panel.classList.toggle('panel-collapsed', !this.isOpen);
                if (this.isOpen) {
                    this.viz.resize();
                    this.updateViz();
                }
            }

            updateViz() {
                const config = this.currentZone === 'web' ? this.audio.webPreset : this.audio.harpPreset;
                this.viz.draw(config);
            }

            render(zone) {
                const config = zone === 'web' ? this.audio.webPreset : this.audio.harpPreset;
                const container = document.getElementById(`${zone}-config`);
                
                container.innerHTML = `
                    <div class="preset-info">
                        Editing: <span style="color: #fff">${config.name}</span>
                    </div>

                    <div class="config-group">
                        <h3>Oscillator</h3>
                        <div class="control-row">
                            <select data-param="oscillator" data-zone="${zone}">
                                <option value="sine" ${config.oscillator === 'sine' ? 'selected' : ''}>Sine</option>
                                <option value="triangle" ${config.oscillator === 'triangle' ? 'selected' : ''}>Triangle</option>
                                <option value="square" ${config.oscillator === 'square' ? 'selected' : ''}>Square</option>
                                <option value="sawtooth" ${config.oscillator === 'sawtooth' ? 'selected' : ''}>Sawtooth</option>
                            </select>
                        </div>
                    </div>

                    <div class="config-group">
                        <h3>Envelope (ADSR)</h3>
                        ${this.rangeInput(zone, 'envelope.attack', 'Attack', config.envelope.attack, 0, 5, 0.01, 's')}
                        ${this.rangeInput(zone, 'envelope.decay', 'Decay', config.envelope.decay, 0, 5, 0.01, 's')}
                        ${this.rangeInput(zone, 'envelope.sustain', 'Sustain', config.envelope.sustain, 0, 1, 0.01, '')}
                        ${this.rangeInput(zone, 'envelope.release', 'Release', config.envelope.release, 0, 20, 0.1, 's')}
                    </div>

                    <div class="config-group">
                        <h3>Filter & Effects</h3>
                        ${this.rangeInput(zone, 'filter', 'Filter Freq', config.filter, 100, 10000, 100, 'Hz')}
                        ${this.rangeInput(zone, 'reverb', 'Reverb Wet', config.reverb, 0, 1, 0.01, '')}
                    </div>

                    <div class="config-group">
                        <h3>Notes (MIDI)</h3>
                        <div class="control-row">
                            <input type="text" data-param="notes" data-zone="${zone}" value="${config.notes.join(', ')}">
                        </div>
                    </div>
                `;

                // Bind events for this zone
                container.querySelectorAll('input, select').forEach(el => {
                    el.oninput = (e) => this.handleInput(e);
                });
            }

            rangeInput(zone, param, label, value, min, max, step, unit) {
                return `
                    <div class="control-row">
                        <label>
                            ${label}
                            <span class="val" id="val-${zone}-${param.replace('.', '-')}">${value}${unit}</span>
                        </label>
                        <input type="range" 
                            data-zone="${zone}" 
                            data-param="${param}" 
                            data-unit="${unit}"
                            min="${min}" max="${max}" step="${step}" value="${value}">
                    </div>
                `;
            }

            handleInput(e) {
                const zone = e.target.dataset.zone;
                const param = e.target.dataset.param;
                const unit = e.target.dataset.unit || '';
                let value = e.target.value;

                if (e.target.type === 'range') {
                    value = parseFloat(value);
                    document.getElementById(`val-${zone}-${param.replace('.', '-')}`).textContent = value + unit;
                } else if (param === 'notes') {
                    value = value.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
                }

                // Construct update object
                const update = {};
                if (param.includes('.')) {
                    const [p1, p2] = param.split('.');
                    update[p1] = { [p2]: value };
                } else {
                    update[param] = value;
                }

                this.audio.updateParams(zone, update);
                
                // Update visualization if we're editing the currently viewed zone
                if (zone === this.currentZone) {
                    this.updateViz();
                }
            }

            export() {
                const data = {
                    web: this.audio.webPreset,
                    harp: this.audio.harpPreset,
                    exportedAt: new Date().toISOString()
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `seilnetz-config-${Date.now()}.json`;
                a.click();
            }

            import(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.web) this.audio.updateParams('web', data.web);
                        if (data.harp) this.audio.updateParams('harp', data.harp);
                        this.render('web');
                        this.render('harp');
                        this.updateViz();
                        alert('Config imported successfully!');
                    } catch (err) {
                        alert('Error parsing JSON config');
                    }
                };
                reader.readAsText(file);
            }
        }

        // ===== MIDI HANDLER =====
        class MIDIHandler {
            constructor(bus) {
                this.bus = bus;
                this.init();
            }

            async init() {
                if (!navigator.requestMIDIAccess) return;
                
                try {
                    const midi = await navigator.requestMIDIAccess();
                    midi.inputs.forEach(input => {
                        input.onmidimessage = e => this.handleMessage(e);
                        this.bus.emit('midi-connected', input.name);
                    });
                } catch (err) {
                    console.warn('MIDI not available:', err);
                }
            }

            handleMessage(e) {
                const [status, note, velocity] = e.data;
                const isNoteOn = (status & 0xF0) === 0x90 && velocity > 0;
                
                if (isNoteOn) {
                    // Map MIDI note to sensor
                    const sensor = NOTE_MAP[note];
                    if (sensor !== undefined) {
                        this.bus.emit('trigger', { sensor, velocity });
                    }
                }
            }
        }

        // ===== TEST SUITE =====
        class TestSuite {
            constructor(bus, audio, config, midi) {
                this.bus = bus;
                this.audio = audio;
                this.config = config;
                this.midi = midi;
                this.resultsEl = document.getElementById('test-results');
                
                document.getElementById('btn-run-tests').onclick = () => this.runAll();
            }

            log(msg, type = 'info') {
                const line = document.createElement('div');
                line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
                line.className = `test-${type}`;
                this.resultsEl.prepend(line);
            }

            assert(condition, message) {
                if (condition) {
                    this.log(`PASS: ${message}`, 'pass');
                    return true;
                } else {
                    this.log(`FAIL: ${message}`, 'fail');
                    return false;
                }
            }

            async runAll() {
                this.resultsEl.innerHTML = '';
                this.log('Starting Integration Tests...', 'info');
                
                try {
                    await this.testAudioTrigger();
                    await this.testPresetChange();
                    await this.testParamUpdate();
                    await this.testNoteMapping();
                    await this.testConfigExport();
                    await this.testVibrationLogic();
                    await this.testBurstLogic();
                    this.log('Tests Completed.', 'info');
                } catch (e) {
                    this.log(`Test Suite Error: ${e.message}`, 'fail');
                }
            }

            async testAudioTrigger() {
                this.log('Testing Audio Trigger...', 'info');
                const sensor = 0;
                const initialVoice = this.audio.activeVoices[sensor].active;
                
                this.bus.emit('trigger', { sensor, velocity: 100 });
                
                await new Promise(r => setTimeout(r, 50));
                
                const active = this.audio.activeVoices[sensor].active;
                this.assert(!initialVoice && active, 'Voice 0 should activate on trigger');
            }

            async testPresetChange() {
                this.log('Testing Preset Change...', 'info');
                const initialPreset = this.audio.webPreset.name;
                
                // Change to a different preset
                const newPreset = initialPreset === 'Ambient Drone' ? 'warm_pad' : 'ambient_drone';
                this.bus.emit('web-preset', newPreset);
                
                await new Promise(r => setTimeout(r, 50));
                
                const currentName = this.audio.webPreset.name;
                // WEB_PRESETS keys are lowercase, names are Title Case
                // 'ambient_drone' -> 'Ambient Drone'
                const expectedName = WEB_PRESETS[newPreset].name;
                
                this.assert(currentName === expectedName, `Web preset should change to ${expectedName}`);
            }

            async testParamUpdate() {
                this.log('Testing Parameter Update...', 'info');
                const initialFilter = this.audio.webPreset.filter;
                const newFilter = initialFilter === 2000 ? 3000 : 2000;
                
                this.audio.updateParams('web', { filter: newFilter });
                
                await new Promise(r => setTimeout(r, 50));
                
                const currentFilter = this.audio.filters.web.frequency.value;
                this.assert(Math.abs(currentFilter - newFilter) < 1, `Filter frequency should update to ${newFilter}Hz`);
            }

            async testNoteMapping() {
                this.log('Testing MIDI Mapping...', 'info');
                let triggered = false;
                const handler = () => { triggered = true; };
                
                // Listen for trigger
                // We need to temporarily subscribe to verify the MIDI handler emits correctly
                // But MIDIHandler listens to hardware. We can verify NOTE_MAP logic directly 
                // or simulate the logic if we exposed a public handle method.
                // Since handleMessage is bound to hardware, let's unit test the map logic logic here:
                
                const midiNote = 60; // C4 -> Sensor 0
                const expectedSensor = 0;
                const mapped = NOTE_MAP[midiNote];
                
                this.assert(mapped === expectedSensor, `MIDI Note 60 should map to Sensor 0`);
            }

            async testConfigExport() {
                this.log('Testing Config Export...', 'info');
                // We can't easily test file download interaction, but we can verify data structure
                const data = {
                    web: this.audio.webPreset,
                    harp: this.audio.harpPreset,
                    exportedAt: new Date().toISOString()
                };
                
                this.assert(data.web && data.harp, 'Export data should contain web and harp configs');
                this.assert(data.web.notes.length > 0, 'Web config should have notes');
            }

            async testVibrationLogic() {
                this.log('Testing Vibration Logic...', 'info');
                // Access viz instance from global scope (since we didn't pass it to TestSuite, let's fix that or use global)
                // Assuming `viz` is available in scope or we pass it
                if (typeof viz === 'undefined') {
                    this.log('Visualizer instance not found', 'fail');
                    return;
                }

                const initialShake = viz.webShake;
                viz.pulse(0); // Trigger web sensor
                
                const triggeredShake = viz.webShake;
                this.assert(triggeredShake === 1.0, 'Web shake should be 1.0 after pulse');

                // Simulate frame decay manually if possible, or wait
                // Since animate runs on requestAnimationFrame, we can just wait a bit
                await new Promise(r => setTimeout(r, 50));
                
                const decayedShake = viz.webShake;
                this.assert(decayedShake < 1.0 && decayedShake > 0, 'Shake should decay over time');
            }

            async testBurstLogic() {
                this.log('Testing Burst Logic...', 'info');
                let triggerCount = 0;
                
                // Spy on bus emit
                const originalEmit = this.bus.emit;
                this.bus.emit = (event, data) => {
                    if (event === 'trigger') triggerCount++;
                    originalEmit.call(this.bus, event, data);
                };

                // Trigger a burst
                ui.triggerBurst(); // Access global UI instance

                // Wait for burst duration (approx 500ms)
                await new Promise(r => setTimeout(r, 600));

                // Restore spy
                this.bus.emit = originalEmit;

                this.assert(triggerCount >= 1, `Burst should trigger multiple events (got ${triggerCount})`);
            }
        }

        // ===== INIT =====
        const bus = new Bus();
        const audio = new AudioEngine(bus);
        const viz = new Visualizer('canvas', bus);
        const voiceViz = new VoiceVisualizer('voices-canvas', bus);
        const ui = new UI(bus);
        const debug = new DebugPanel(bus, audio);
        const config = new Configurator(bus, audio);
        const midi = new MIDIHandler(bus);
        const tests = new TestSuite(bus, audio, config, midi);

        // Start audio on first interaction
        document.body.addEventListener('click', () => {
            if (!audio.ready) audio.init();
        }, { once: true });
    </script>
</body>
</html>
