<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seilnetz V3.0: Sonic Web + Harp</title>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'SF Mono', 'Menlo', monospace;
            background: #1a1a1a;
            color: #f5f5f5;
            overflow: hidden;
            height: 100vh;
        }

        #canvas { 
            position: fixed; 
            inset: 0; 
            z-index: 0; 
        }

        #ui {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 380px;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            z-index: 10;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        h1 {
            font-size: 1rem;
            color: #d4a017;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 2px solid #d4a017;
            padding-bottom: 10px;
        }

        h2 {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 20px 0 10px 0;
        }

        .status {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.8rem;
        }

        .led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
            transition: all 0.3s;
        }

        .led.on { 
            background: #0f0; 
            box-shadow: 0 0 10px #0f0; 
        }

        button, select {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background: #2a2a2a;
            color: #f5f5f5;
            border: 1px solid #444;
            font-family: inherit;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover { background: #3a3a3a; }
        button.active { background: #d4a017; color: #000; }

        #voices-canvas {
            width: 100%;
            height: 180px;
            background: #0a0a0a;
            border: 1px solid #333;
            margin: 10px 0;
        }

        #log {
            background: #0a0a0a;
            border: 1px solid #333;
            padding: 10px;
            height: 120px;
            overflow-y: auto;
            font-size: 0.65rem;
            color: #888;
        }

        .info {
            font-size: 0.7rem;
            color: #666;
            margin-top: 10px;
            line-height: 1.4;
        }

        .key { 
            color: #d4a017; 
            font-weight: bold; 
        }

        /* === DEBUG PANEL === */
        #debug-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(20, 20, 20, 0.98);
            border-top: 2px solid #333;
            z-index: 100;
            transition: transform 0.3s ease;
            font-family: inherit;
        }

        #debug-panel.debug-collapsed {
            transform: translateY(calc(100% - 40px));
        }

        #debug-toggle {
            width: 100px;
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.98);
            border: 2px solid #333;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            padding: 8px;
            cursor: pointer;
            color: #d4a017;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 101;
        }

        #debug-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .debug-section {
            background: #0a0a0a;
            border: 1px solid #333;
            padding: 15px;
            border-radius: 4px;
        }

        .debug-section h3 {
            font-size: 0.7rem;
            color: #d4a017;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .debug-stat {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            margin-bottom: 6px;
            color: #888;
        }

        .debug-stat span:last-child {
            color: #0f0;
            font-family: monospace;
        }

        .debug-log, #dbg-preset-config {
            background: #000;
            padding: 10px;
            font-size: 0.6rem;
            font-family: monospace;
            color: #0f0;
            max-height: 180px;
            overflow-y: auto;
            white-space: pre-wrap;
            border: 1px solid #222;
        }

        #labels-container {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 5;
        }

        .node-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #d4a017;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            border: 1px solid #333;
            white-space: nowrap;
            transform: translate(-50%, -50%);
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .node-label.hidden {
            opacity: 0;
        }
    </style>
</head>
<body>
    <div id="canvas"></div>
    
    <div id="ui">
        <h1>üï∏Ô∏è Seilnetz V3.1</h1>
        
        <h2>Status</h2>
        <div class="status">
            <div id="led-audio" class="led"></div>
            <span>Audio Engine</span>
        </div>
        <div class="status">
            <div id="led-midi" class="led"></div>
            <span id="midi-status">No MIDI</span>
        </div>

        <h2>Soundscape</h2>
        <div style="margin-bottom: 15px;">
            <label style="font-size: 0.65rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 4px;">Web</label>
            <select id="web-preset">
                <option value="ambient_drone">Ambient Drone</option>
                <option value="warm_pad">Warm Pad</option>
                <option value="deep_bass">Deep Bass</option>
                <option value="bright_shimmer">Bright Shimmer</option>
                <option value="dark_pulse">Dark Pulse</option>
                <option value="crystal_bells">Crystal Bells</option>
            </select>

            <label style="font-size: 0.65rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 4px;">Harp</label>
            <select id="harp-preset">
                <option value="monochord">Monochord</option>
                <option value="plucked_strings">Plucked Strings</option>
                <option value="bell_tones">Bell Tones</option>
                <option value="soft_mallets">Soft Mallets</option>
                <option value="aggressive_hits">Aggressive Hits</option>
                <option value="ethereal_bow">Ethereal Bow</option>
            </select>
        </div>

        <h2>Active Voices</h2>
        <canvas id="voices-canvas"></canvas>

        <h2>Controls</h2>
        <button id="btn-toggle-labels">Show/Hide Labels</button>
        <button id="btn-autoplay">Toggle Auto-Play</button>

        <div class="info">
            <strong>Keyboard:</strong> 
            <span class="key">1-2</span> = Web, 
            <span class="key">3</span> = Harp<br>
            <strong>Mouse:</strong> Drag to rotate<br>
            <strong>Debug:</strong> Toggle footer panel
        </div>
    </div>

    <div id="debug-panel" class="debug-collapsed">
        <button id="debug-toggle">DEBUG ‚ñ≤</button>
        <div id="debug-content">
            <div class="debug-section">
                <h3>MIDI Diagnostics</h3>
                <div class="debug-stat"><span>API:</span> <span id="dbg-midi-api">-</span></div>
                <div class="debug-stat"><span>Device:</span> <span id="dbg-midi-device">-</span></div>
                <div class="debug-stat"><span>Last Msg:</span> <span id="dbg-midi-last">-</span></div>
                <div id="midi-log" class="debug-log">Waiting for MIDI...</div>
            </div>
            
            <div class="debug-section">
                <h3>Preset Config</h3>
                <pre id="dbg-preset-config" style="height: 180px;"></pre>
            </div>
            
            <div class="debug-section">
                <h3>Synth Params</h3>
                <div id="dbg-synth-params" class="debug-log" style="height: 180px;"></div>
            </div>
            
            <div class="debug-section">
                <h3>Voice States</h3>
                <div id="dbg-voice-states" class="debug-log" style="height: 180px;"></div>
            </div>
            
            <div class="debug-section">
                <h3>Event Log</h3>
                <div id="log" class="debug-log" style="height: 180px;"></div>
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        const WEB_PRESETS = {
            ambient_drone: {
                name: 'Ambient Drone',
                notes: [36, 43, 52, 59],  // C2, G2, E3, B3
                envelope: { attack: 1.2, decay: 0.5, sustain: 0.7, release: 12 },
                oscillator: 'sine',
                filter: 2000,
                reverb: 0.8
            },
            warm_pad: {
                name: 'Warm Pad',
                notes: [48, 52, 55, 59],  // C3, E3, G3, B3
                envelope: { attack: 0.8, decay: 0.4, sustain: 0.8, release: 10 },
                oscillator: 'triangle',
                filter: 3000,
                reverb: 0.6
            },
            deep_bass: {
                name: 'Deep Bass',
                notes: [28, 35, 40, 47],  // E1, B1, E2, B2
                envelope: { attack: 2, decay: 1, sustain: 0.6, release: 15 },
                oscillator: 'sine',
                filter: 1500,
                reverb: 0.9
            },
            bright_shimmer: {
                name: 'Bright Shimmer',
                notes: [60, 64, 67, 71],  // C4, E4, G4, B4
                envelope: { attack: 0.3, decay: 0.2, sustain: 0.9, release: 6 },
                oscillator: 'triangle',
                filter: 6000,
                reverb: 0.4
            },
            dark_pulse: {
                name: 'Dark Pulse',
                notes: [39, 44, 49, 54],  // D#2, G#2, C#3, F#3
                envelope: { attack: 0.5, decay: 0.6, sustain: 0.5, release: 8 },
                oscillator: 'sine',
                filter: 1800,
                reverb: 0.7
            },
            crystal_bells: {
                name: 'Crystal Bells',
                notes: [72, 76, 79, 83],  // C5, E5, G5, B5
                envelope: { attack: 0.01, decay: 0.3, sustain: 0.4, release: 5 },
                oscillator: 'triangle',
                filter: 8000,
                reverb: 0.5
            }
        };

        const HARP_PRESETS = {
            monochord: {
                name: 'Monochord',
                notes: [62, 67],  // D4, G4
                envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 4 },
                oscillator: 'triangle',
                filter: 5000,
                reverb: 0.5
            },
            plucked_strings: {
                name: 'Plucked Strings',
                notes: [64, 69],  // E4, A4
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 2 },
                oscillator: 'triangle',
                filter: 6000,
                reverb: 0.3
            },
            bell_tones: {
                name: 'Bell Tones',
                notes: [60, 67],  // C4, G4
                envelope: { attack: 0.02, decay: 0.5, sustain: 0.2, release: 6 },
                oscillator: 'triangle',
                filter: 7000,
                reverb: 0.6
            },
            soft_mallets: {
                name: 'Soft Mallets',
                notes: [55, 62],  // G3, D4
                envelope: { attack: 0.1, decay: 0.4, sustain: 0.4, release: 3 },
                oscillator: 'sine',
                filter: 4000,
                reverb: 0.4
            },
            aggressive_hits: {
                name: 'Aggressive Hits',
                notes: [48, 60],  // C3, C4
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.6, release: 1.5 },
                oscillator: 'square',
                filter: 8000,
                reverb: 0.2
            },
            ethereal_bow: {
                name: 'Ethereal Bow',
                notes: [68, 75],  // G#4, D#5
                envelope: { attack: 0.5, decay: 0.6, sustain: 0.7, release: 8 },
                oscillator: 'sine',
                filter: 5500,
                reverb: 0.8
            }
        };

        // MIDI Note Mapping (for testing with keyboard/controllers)
        const NOTE_MAP = { 60: 0, 62: 1, 64: 2 }; // C, D, E

        // 3D Positions
        const WEB_NODES = [
            { x: -1.5, y: 0.5, z: 0, label: 'Web 1' },
            { x: 1.5, y: 0.5, z: 0, label: 'Web 2' }
        ];

        const HARP_NODES = [
            { x: 0, y: 2, z: -1, label: 'Harp' }
        ];

        const ALL_NODES = [...WEB_NODES, ...HARP_NODES];

        // ===== EVENT BUS =====
        class Bus {
            constructor() { this.subs = {}; }
            on(e, fn) { (this.subs[e] ||= []).push(fn); }
            emit(e, d) { this.subs[e]?.forEach(fn => fn(d)); }
        }

        // ===== AUDIO ENGINE =====
        class AudioEngine {
            constructor(bus) {
                this.bus = bus;
                this.webSynth = null;
                this.harpSynth = null;
                this.filters = { web: null, harp: null };
                this.reverbs = { web: null, harp: null };
                this.webPreset = WEB_PRESETS.ambient_drone;
                this.harpPreset = HARP_PRESETS.monochord;
                this.ready = false;
                this.activeVoices = new Array(3).fill(null).map(() => ({ 
                    active: false, 
                    startTime: 0, 
                    duration: 0,
                    note: null 
                }));

                bus.on('trigger', d => this.play(d.sensor, d.velocity));
                bus.on('web-preset', name => this.setWebPreset(name));
                bus.on('harp-preset', name => this.setHarpPreset(name));
            }

            async init() {
                await Tone.start();
                
                // Web synth (4 voices)
                this.webSynth = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 4 });
                this.filters.web = new Tone.Filter(2000, 'lowpass');
                this.reverbs.web = new Tone.Reverb({ decay: 8, wet: 0.5 });
                this.webSynth.chain(this.filters.web, this.reverbs.web, Tone.Destination);

                // Harp synth (2 voices)
                this.harpSynth = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 2 });
                this.filters.harp = new Tone.Filter(5000, 'lowpass');
                this.reverbs.harp = new Tone.Reverb({ decay: 4, wet: 0.3 });
                this.harpSynth.chain(this.filters.harp, this.reverbs.harp, Tone.Destination);

                this.applyPreset();
                this.ready = true;
                this.bus.emit('audio-ready');
            }

            setWebPreset(name) {
                this.webPreset = WEB_PRESETS[name] || WEB_PRESETS.ambient_drone;
                if (this.ready) this.applyPreset();
            }

            setHarpPreset(name) {
                this.harpPreset = HARP_PRESETS[name] || HARP_PRESETS.monochord;
                if (this.ready) this.applyPreset();
            }

            applyPreset() {
                const web = this.webPreset;
                const harp = this.harpPreset;
                
                this.webSynth.set({
                    oscillator: { type: web.oscillator },
                    envelope: web.envelope
                });
                this.filters.web.frequency.value = web.filter;
                this.reverbs.web.wet.value = web.reverb;

                this.harpSynth.set({
                    oscillator: { type: harp.oscillator },
                    envelope: harp.envelope
                });
                this.filters.harp.frequency.value = harp.filter;
                this.reverbs.harp.wet.value = harp.reverb;
            }

            play(sensor, velocity) {
                if (!this.ready) return;

                const isHarp = sensor >= 2;
                const synth = isHarp ? this.harpSynth : this.webSynth;
                const config = isHarp ? this.harpPreset : this.webPreset;
                const noteIndex = isHarp ? sensor - 2 : sensor;
                const midiNote = config.notes[noteIndex % config.notes.length];
                const noteName = Tone.Frequency(midiNote, 'midi').toNote();
                const volume = velocity / 127;

                // Trigger
                synth.triggerAttack(noteName, Tone.now(), volume);
                const holdTime = config.envelope.attack + 0.1;
                synth.triggerRelease(noteName, Tone.now() + holdTime);

                // Track voice for visualization
                const totalDuration = config.envelope.attack + config.envelope.decay + config.envelope.release + 1;
                this.activeVoices[sensor] = {
                    active: true,
                    startTime: Date.now(),
                    duration: totalDuration * 1000,
                    note: noteName,
                    envelope: config.envelope
                };

                // Auto-deactivate after duration
                setTimeout(() => {
                    if (this.activeVoices[sensor].startTime === this.activeVoices[sensor].startTime) {
                        this.activeVoices[sensor].active = false;
                    }
                }, totalDuration * 1000);

                this.bus.emit('voice-update', this.activeVoices);
            }

            getActiveVoices() {
                return this.activeVoices;
            }
        }

        // ===== VOICE VISUALIZER =====
        class VoiceVisualizer {
            constructor(canvasId, bus) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.bus = bus;
                this.voices = new Array(6).fill(null).map(() => ({ active: false }));
                
                bus.on('voice-update', voices => {
                    this.voices = voices;
                });

                this.animate();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.draw();
            }

            draw() {
                const { width, height } = this.canvas;
                const ctx = this.ctx;
                const barHeight = height / 6;
                const now = Date.now();

                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, width, height);

                this.voices.forEach((voice, i) => {
                    const y = i * barHeight;
                    const isHarp = i >= 2;
                    const color = isHarp ? '#d4a017' : '#cc2936';
                    const label = isHarp ? `Harp ${i - 1}` : `Web ${i + 1}`;

                    // Background
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(0, y, width, barHeight - 2);

                    // Label
                    ctx.fillStyle = '#666';
                    ctx.font = '10px monospace';
                    ctx.fillText(label, 8, y + 15);

                    if (voice.active) {
                        const elapsed = now - voice.startTime;
                        const progress = Math.min(elapsed / voice.duration, 1);
                        const env = voice.envelope;
                        
                        // Calculate envelope position
                        const attackT = env.attack / (voice.duration / 1000);
                        const decayT = (env.attack + env.decay) / (voice.duration / 1000);
                        const sustainT = (env.attack + env.decay + 1) / (voice.duration / 1000);
                        
                        let amplitude = 0;
                        if (progress < attackT) {
                            amplitude = progress / attackT;
                        } else if (progress < decayT) {
                            amplitude = 1 - ((progress - attackT) / (decayT - attackT)) * (1 - env.sustain);
                        } else if (progress < sustainT) {
                            amplitude = env.sustain;
                        } else {
                            amplitude = env.sustain * (1 - (progress - sustainT) / (1 - sustainT));
                        }

                        // Bar
                        const barWidth = width * progress;
                        const barAlpha = Math.max(0.3, amplitude);
                        ctx.fillStyle = color + Math.floor(barAlpha * 255).toString(16).padStart(2, '0');
                        ctx.fillRect(0, y, barWidth, barHeight - 2);

                        // Time remaining
                        const remaining = ((voice.duration - elapsed) / 1000).toFixed(1);
                        ctx.fillStyle = '#fff';
                        ctx.fillText(`${remaining}s`, width - 40, y + 15);

                        // Note name
                        if (voice.note) {
                            ctx.fillText(voice.note, 80, y + 15);
                        }
                    } else {
                        // Idle
                        ctx.fillStyle = '#444';
                        ctx.fillText('idle', 80, y + 15);
                    }
                });
            }
        }

        // ===== 3D VISUALIZER =====
        class Visualizer {
            constructor(containerId, bus) {
                this.bus = bus;
                this.nodes = [];
                this.labels = [];
                this.showLabels = true;

                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a0a);

                this.camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
                this.camera.position.set(-3, 5, 8);
                this.camera.lookAt(0, 1, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(innerWidth, innerHeight);
                this.renderer.setPixelRatio(devicePixelRatio);
                document.getElementById(containerId).appendChild(this.renderer.domElement);

                // Lights
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const sun = new THREE.DirectionalLight(0xffffff, 0.6);
                sun.position.set(5, 10, 5);
                this.scene.add(sun);

                this.setupControls();
                this.createStructure();
                this.animate();

                bus.on('trigger', d => this.pulse(d.sensor));
                bus.on('toggle-labels', show => this.toggleLabels(show));
                window.addEventListener('resize', () => this.resize());
            }

            setupControls() {
                const canvas = this.renderer.domElement;
                let isDragging = false, prevMouse = { x: 0, y: 0 };
                let rot = { x: 0.7, y: -0.3 };

                canvas.addEventListener('mousedown', e => {
                    isDragging = true;
                    prevMouse = { x: e.clientX, y: e.clientY };
                });

                canvas.addEventListener('mousemove', e => {
                    if (!isDragging) return;
                    const dx = e.clientX - prevMouse.x;
                    const dy = e.clientY - prevMouse.y;
                    rot.y += dx * 0.005;
                    rot.x += dy * 0.005;
                    rot.x = Math.max(0.2, Math.min(1.5, rot.x));

                    const dist = 10;
                    this.camera.position.x = Math.sin(rot.y) * dist * Math.cos(rot.x);
                    this.camera.position.z = Math.cos(rot.y) * dist * Math.cos(rot.x);
                    this.camera.position.y = Math.sin(rot.x) * dist;
                    this.camera.lookAt(0, 1, 0);

                    prevMouse = { x: e.clientX, y: e.clientY };
                });

                canvas.addEventListener('mouseup', () => isDragging = false);
                canvas.addEventListener('mouseleave', () => isDragging = false);
            }

            createStructure() {
                this.group = new THREE.Group();
                this.scene.add(this.group);

                // Materials
                const webMat = new THREE.LineBasicMaterial({ color: 0xcc2936, linewidth: 2 }); // Red
                const harpMat = new THREE.LineBasicMaterial({ color: 0xd4a017, linewidth: 2 }); // Yellow
                const structureMat = new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 1 }); // Grey

                // Create sensor nodes
                ALL_NODES.forEach((pos, i) => {
                    const isHarp = i >= 2;
                    const color = isHarp ? 0xd4a017 : 0xcc2936;
                    
                    const geo = new THREE.SphereGeometry(0.25, 32, 32);
                    const mat = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        emissive: color,
                        emissiveIntensity: 0.3,
                        roughness: 0.3,
                        metalness: 0.1
                    });
                    
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(pos.x, pos.y, pos.z);
                    this.group.add(mesh);
                    this.nodes.push(mesh);
                });

                // Web radial spokes (12 lines from center)
                // Use a virtual center point for visualization
                const centerPos = new THREE.Vector3(0, 0.2, 0);
                const spokeCount = 12;
                const radius = 3.5;
                
                for (let i = 0; i < spokeCount; i++) {
                    const angle = (i / spokeCount) * Math.PI * 2;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const y = 0.2; // Slightly above ground
                    
                    const pts = [
                        centerPos,
                        new THREE.Vector3(x, y, z)
                    ];
                    const geo = new THREE.BufferGeometry().setFromPoints(pts);
                    this.group.add(new THREE.Line(geo, webMat));
                }

                // Concentric rings (2 circles)
                const rings = [
                    { radius: 1.8, segments: 16 },
                    { radius: 3.2, segments: 24 }
                ];
                
                rings.forEach(ring => {
                    const points = [];
                    for (let i = 0; i <= ring.segments; i++) {
                        const angle = (i / ring.segments) * Math.PI * 2;
                        points.push(new THREE.Vector3(
                            Math.cos(angle) * ring.radius,
                            0.2,
                            Math.sin(angle) * ring.radius
                        ));
                    }
                    const geo = new THREE.BufferGeometry().setFromPoints(points);
                    this.group.add(new THREE.Line(geo, webMat));
                });

                // Harp vertical string
                // Visual line for harp
                const harpTop = new THREE.Vector3(0, 3.2, -1);
                const harpBottom = new THREE.Vector3(0, 0, -1);
                const pts = [harpTop, harpBottom];
                const geo = new THREE.BufferGeometry().setFromPoints(pts);
                this.group.add(new THREE.Line(geo, harpMat));

                // Steel truss (torus at base)
                const trussGeo = new THREE.TorusGeometry(3.5, 0.08, 8, 32);
                const trussMat = new THREE.MeshStandardMaterial({ 
                    color: 0x888888, 
                    roughness: 0.5, 
                    metalness: 0.7 
                });
                const truss = new THREE.Mesh(trussGeo, trussMat);
                truss.rotation.x = Math.PI / 2;
                truss.position.y = 0;
                this.scene.add(truss);

                // Overhead beam (cylinder)
                const beamGeo = new THREE.CylinderGeometry(0.06, 0.06, 8, 16);
                const beamMat = new THREE.MeshStandardMaterial({ 
                    color: 0x666666, 
                    roughness: 0.6 
                });
                const beam = new THREE.Mesh(beamGeo, beamMat);
                beam.rotation.z = Math.PI / 2;
                beam.position.set(0, 3.2, 0);
                this.scene.add(beam);

                // Create labels
                this.labelsContainer = document.createElement('div');
                this.labelsContainer.id = 'labels-container';
                document.body.appendChild(this.labelsContainer);

                ALL_NODES.forEach((pos, i) => {
                    const label = document.createElement('div');
                    label.className = 'node-label';
                    const isHarp = i >= 2;
                    const zone = isHarp ? 'Harp' : 'Web';
                    // Web sensors are 1-based index (1, 2)
                    // Harp sensor is 1-based index (1)
                    const num = isHarp ? i - 1 : i + 1;
                    label.innerHTML = `<strong>${zone} ${num}</strong>`;
                    this.labelsContainer.appendChild(label);
                    this.labels.push({ el: label, node: this.nodes[i] });
                });
            }

            pulse(sensor) {
                if (sensor < this.nodes.length) {
                    const node = this.nodes[sensor];
                    const baseIntensity = node.material.emissiveIntensity;
                    
                    node.material.emissiveIntensity = 1.0;
                    
                    setTimeout(() => {
                        node.material.emissiveIntensity = baseIntensity;
                    }, 100);
                }
            }

            toggleLabels(show) {
                this.showLabels = show;
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // Update label positions
                if (this.showLabels) {
                    this.labels.forEach(({ el, node }) => {
                        const screenPos = this.toScreenPosition(node);
                        el.style.left = screenPos.x + 'px';
                        el.style.top = screenPos.y + 'px';
                        el.classList.remove('hidden');
                    });
                } else {
                    this.labels.forEach(({ el }) => el.classList.add('hidden'));
                }

                this.renderer.render(this.scene, this.camera);
            }

            toScreenPosition(obj) {
                const vector = obj.position.clone();
                vector.project(this.camera);
                
                return {
                    x: (vector.x + 1) / 2 * innerWidth,
                    y: -(vector.y - 1) / 2 * innerHeight
                };
            }

            resize() {
                this.camera.aspect = innerWidth / innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(innerWidth, innerHeight);
            }
        }

        // ===== DEBUG PANEL =====
        class DebugPanel {
            constructor(bus, audio) {
                this.bus = bus;
                this.audio = audio;
                this.isOpen = false;
                this.panel = document.getElementById('debug-panel');
                
                // Toggle button
                document.getElementById('debug-toggle').onclick = () => this.toggle();
                
                // Update loop
                setInterval(() => this.update(), 200);
                
                // MIDI API Check
                const apiStat = document.getElementById('dbg-midi-api');
                if (navigator.requestMIDIAccess) {
                    apiStat.textContent = "Available";
                    apiStat.style.color = "#0f0";
                } else {
                    apiStat.textContent = "Not Supported";
                    apiStat.style.color = "#f00";
                }

                // MIDI logging
                bus.on('midi-connected', name => {
                    document.getElementById('dbg-midi-device').textContent = name;
                });
                
                bus.on('trigger', d => {
                    const zone = d.sensor >= 2 ? 'Harp' : 'Web';
                    this.logMIDI(`${zone} Sensor ${d.sensor} | Velocity: ${d.velocity}`);
                });
            }
            
            toggle() {
                this.isOpen = !this.isOpen;
                this.panel.classList.toggle('debug-collapsed', !this.isOpen);
                const btn = document.getElementById('debug-toggle');
                btn.textContent = this.isOpen ? 'DEBUG ‚ñº' : 'DEBUG ‚ñ≤';
            }
            
            update() {
                if (!this.isOpen) return;

                // Preset config
                document.getElementById('dbg-preset-config').textContent = 
                    JSON.stringify({
                        web: this.audio.webPreset,
                        harp: this.audio.harpPreset
                    }, null, 2);
                
                // Synth parameters
                const params = document.getElementById('dbg-synth-params');
                params.innerHTML = `
                    <div style="color: #d4a017; margin-bottom: 5px;">Web Parameters:</div>
                    <div>Filter: ${this.audio.filters.web?.frequency.value.toFixed(0)}Hz</div>
                    <div>Reverb: ${(this.audio.reverbs.web?.wet.value * 100).toFixed(0)}%</div>
                    <div>Osc: ${this.audio.webPreset.oscillator}</div>
                    
                    <div style="color: #d4a017; margin-top: 15px; margin-bottom: 5px;">Harp Parameters:</div>
                    <div>Filter: ${this.audio.filters.harp?.frequency.value.toFixed(0)}Hz</div>
                    <div>Reverb: ${(this.audio.reverbs.harp?.wet.value * 100).toFixed(0)}%</div>
                    <div>Osc: ${this.audio.harpPreset.oscillator}</div>
                `;
                
                // Voice states
                const states = document.getElementById('dbg-voice-states');
                states.innerHTML = this.audio.activeVoices.map((v, i) => 
                    `<div>Sensor ${i}: ${v.active ? `<span style="color:#0f0">ACTIVE (${v.note})</span>` : '<span style="color:#444">idle</span>'}</div>`
                ).join('');
            }
            
            logMIDI(msg) {
                const log = document.getElementById('midi-log');
                const line = document.createElement('div');
                line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
                log.prepend(line);
                if (log.children.length > 50) log.lastChild.remove();
                
                document.getElementById('dbg-midi-last').textContent = msg;
            }
        }

        // ===== UI CONTROLLER =====
        class UI {
            constructor(bus) {
                this.bus = bus;
                this.log = document.getElementById('log');
                this.autoplayInterval = null;
                this.showLabels = true;

                // Status LEDs
                bus.on('audio-ready', () => {
                    document.getElementById('led-audio').classList.add('on');
                });

                bus.on('midi-connected', name => {
                    document.getElementById('led-midi').classList.add('on');
                    document.getElementById('midi-status').textContent = name;
                });

                // Preset selectors
                document.getElementById('web-preset').addEventListener('change', e => {
                    bus.emit('web-preset', e.target.value);
                    this.addLog(`Web Preset: ${e.target.value}`);
                });

                document.getElementById('harp-preset').addEventListener('change', e => {
                    bus.emit('harp-preset', e.target.value);
                    this.addLog(`Harp Preset: ${e.target.value}`);
                });

                // Toggle labels
                document.getElementById('btn-toggle-labels').addEventListener('click', () => {
                    this.showLabels = !this.showLabels;
                    bus.emit('toggle-labels', this.showLabels);
                });

                // Auto-play
                document.getElementById('btn-autoplay').addEventListener('click', () => {
                    this.toggleAutoplay();
                });

                // Keyboard input
                document.addEventListener('keydown', e => {
                    const keyMap = { '1': 0, '2': 1, '3': 2 };
                    if (keyMap[e.key] !== undefined) {
                        const velocity = 40 + Math.random() * 80;  // Random 40-120
                        bus.emit('trigger', { sensor: keyMap[e.key], velocity: Math.floor(velocity) });
                    }
                });

                // Log triggers
                bus.on('trigger', d => {
                    const zone = d.sensor >= 2 ? 'Harp' : 'Web';
                    this.addLog(`${zone} Sensor ${d.sensor} | Vel: ${d.velocity}`);
                });
            }

            toggleAutoplay() {
                if (this.autoplayInterval) {
                    clearInterval(this.autoplayInterval);
                    this.autoplayInterval = null;
                    document.getElementById('btn-autoplay').classList.remove('active');
                    this.addLog('Auto-play stopped');
                } else {
                    this.autoplayInterval = setInterval(() => {
                        // Web: gentle, infrequent
                        if (Math.random() < 0.3) {
                            const sensor = Math.floor(Math.random() * 2);
                            const velocity = 30 + Math.random() * 50;
                            this.bus.emit('trigger', { sensor, velocity: Math.floor(velocity) });
                        }
                        
                        // Harp: occasional plucks
                        if (Math.random() < 0.15) {
                            const sensor = 2; // Only 1 harp sensor at index 2
                            const velocity = 60 + Math.random() * 60;
                            this.bus.emit('trigger', { sensor, velocity: Math.floor(velocity) });
                        }
                    }, 1000);
                    document.getElementById('btn-autoplay').classList.add('active');
                    this.addLog('Auto-play started');
                }
            }

            addLog(msg) {
                const line = document.createElement('div');
                line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
                this.log.prepend(line);
                if (this.log.children.length > 50) this.log.lastChild.remove();
            }
        }

        // ===== MIDI HANDLER =====
        class MIDIHandler {
            constructor(bus) {
                this.bus = bus;
                this.init();
            }

            async init() {
                if (!navigator.requestMIDIAccess) return;
                
                try {
                    const midi = await navigator.requestMIDIAccess();
                    midi.inputs.forEach(input => {
                        input.onmidimessage = e => this.handleMessage(e);
                        this.bus.emit('midi-connected', input.name);
                    });
                } catch (err) {
                    console.warn('MIDI not available:', err);
                }
            }

            handleMessage(e) {
                const [status, note, velocity] = e.data;
                const isNoteOn = (status & 0xF0) === 0x90 && velocity > 0;
                
                if (isNoteOn) {
                    // Map MIDI note to sensor
                    const sensor = NOTE_MAP[note];
                    if (sensor !== undefined) {
                        this.bus.emit('trigger', { sensor, velocity });
                    }
                }
            }
        }

        // ===== INIT =====
        const bus = new Bus();
        const audio = new AudioEngine(bus);
        const viz = new Visualizer('canvas', bus);
        const voiceViz = new VoiceVisualizer('voices-canvas', bus);
        const ui = new UI(bus);
        const debug = new DebugPanel(bus, audio);
        const midi = new MIDIHandler(bus);

        // Start audio on first interaction
        document.body.addEventListener('click', () => {
            if (!audio.ready) audio.init();
        }, { once: true });
    </script>
</body>
</html>
